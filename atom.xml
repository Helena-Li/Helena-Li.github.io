<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Helena-Li.github.io</id>
    <title>Web development</title>
    <updated>2020-01-30T11:37:05.367Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Helena-Li.github.io"/>
    <link rel="self" href="https://Helena-Li.github.io/atom.xml"/>
    <logo>https://Helena-Li.github.io/images/avatar.png</logo>
    <icon>https://Helena-Li.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Web development</rights>
    <entry>
        <title type="html"><![CDATA[Ways of using AutoMapper in .NET core]]></title>
        <id>https://Helena-Li.github.io/post/two-ways-to-use-automapper-in-net-core</id>
        <link href="https://Helena-Li.github.io/post/two-ways-to-use-automapper-in-net-core">
        </link>
        <updated>2020-01-24T18:29:54.000Z</updated>
        <content type="html"><![CDATA[<p>Previously, I use this way to map an entity to a data transfer object(DTO):</p>
<pre><code class="language-c#">public class Company
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Introduction { get; set; }

        public ICollection&lt;Employee&gt; Employees { get; set; }
    }
    
    
public class CompanyDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

</code></pre>
<pre><code class="language-c#">[ApiController]
    [Route(&quot;company&quot;)]
    public class CompanyController : Controller
    {
        private readonly ICompanyRepository companyRepository;
        private readonly IMapper mapper;

        public CompanyController(ICompanyRepository companyRepository,IMapper mapper)
        {
            this.companyRepository = companyRepository;
            this.mapper = mapper;
        }
        [HttpGet]
        [Route(&quot;&quot;)]
        public async Task&lt;ActionResult&lt;IEnumerable&lt;CompanyDto&gt;&gt;&gt; GetCompanies()
        {
            var companies = await companyRepository.GetCompaniesAsync();
            var companyDtos = mapper.Map&lt;IEnumerable&lt;CompanyDto&gt;&gt;(companies);
            var model = new List&lt;CompanyDto&gt;();
            foreach (var company in companies)
            {
                CompanyDto companyDto = new CompanyDto
                {
                    Id=company.Id,
                    Name=company.Name
                };
                model.Add(companyDto);
            }
            return Ok(model);
        }
    }
</code></pre>
<p>However, if we use AutoMapper, the situation becomes much easier. There are 4 steps.</p>
<h5 id="install-package">Install package :</h5>
<p>Install AutoMapper.Extensions.Microsoft.DependencyInjection by Nuget package manager.</p>
<h5 id="create-profile">Create profile</h5>
<p>Create a class to build profile:</p>
<pre><code class="language-c#">using AutoMapper;

public class CompanyProfile:Profile
    {
        public CompanyProfile()
        {
            CreateMap&lt;Company, CompanyDto&gt;();
        }
    }
</code></pre>
<h5 id="set-up-startupcs">Set up startup.cs</h5>
<p>There are two way of append AutoMapper :</p>
<pre><code class="language-c#">public void ConfigureServices(IServiceCollection services)
{
	// add AutoMapper
	services.AddAutoMapper();
}
</code></pre>
<p>or</p>
<pre><code class="language-c#">public void ConfigureServices(IServiceCollection services)
{
    // add AutoMapper
            var mappingConfig = new MapperConfiguration(mc =&gt;
            {
                mc.AddProfile(new CompanyProfile());
            });

            IMapper mapper = mappingConfig.CreateMapper();
            services.AddSingleton(mapper);
}
</code></pre>
<p>These two ways get almost same results.</p>
<h5 id="using-imapper-in-a-controller">Using IMapper in a controller</h5>
<p>By using AutoMapper, the codes are as simple as follow:</p>
<pre><code class="language-c#">    [ApiController]
    [Route(&quot;company&quot;)]
    public class CompanyController : Controller
    {
        private readonly ICompanyRepository companyRepository;
        private readonly IMapper mapper;

        public CompanyController(ICompanyRepository companyRepository,
                                 IMapper mapper)
        {
            this.companyRepository = companyRepository;
            this.mapper = mapper;
        }
        [HttpGet]
        [Route(&quot;&quot;)]
        public async Task&lt;ActionResult&lt;IEnumerable&lt;CompanyDto&gt;&gt;&gt; GetCompanies()
        {
            var companies = await companyRepository.GetCompaniesAsync();
            var companyDtos = mapper.Map&lt;IEnumerable&lt;CompanyDto&gt;&gt;(companies);
            return Ok(companyDtos);
        }
    }
</code></pre>
<p>Notice:</p>
<ol>
<li>Entities can either contain more properties or less properties than target DTO</li>
<li>If the name of the Properties are different between two classes, or people need to combine two properties, it also works fine</li>
<li>People can combine two entities into one DTO</li>
</ol>
<h5 id="1contain-more-or-less-properties">1.Contain more or less properties</h5>
<p>As is seen in the beginning, Company class contains a &quot;Introduction&quot; property, using AutoMapper can automatic ignore this property without a null exception. If Company contains less property, for instance, CompanyDto contains a &quot;Location&quot; property, after mapping, the &quot;Location&quot; field in the object will be null.</p>
<h5 id="2-difference-or-combination">2. Difference or Combination</h5>
<p>When property's name is different between the classes, there are methods in AutoMapper can be used. For example, we change the name property to CompayName.</p>
<pre><code class="language-c#">public class Company
    {
        public int Id { get; set; }
        public string CompanyName { get; set; }
        public string Introduction { get; set; }

        public ICollection&lt;Employee&gt; Employees { get; set; }
    }
    
    
public class CompanyDto
    {
        public int Id { get; set; }
        public string Name { get; set; }
    }

</code></pre>
<p>Create mapper can be:</p>
<pre><code class="language-c#">CreateMap&lt;Company, CompanyDto&gt;()
                .ForMember(dest=&gt;dest.CompanyName,
                opt=&gt;opt.MapFrom(src=&gt;src.Name));
</code></pre>
<p>Or if you want to combine two property together in Employee:</p>
<pre><code class="language-c#">public class Employee
    {
        public int Id { get; set; }
        public int CompanyId { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }

        public Company Company { get; set; }
    }
    
 public class EmployeeDto
    {
        public int Id { get; set; }
        public int CompanyId { get; set; }

        public string Name { get; set; }
        public string CompanyName { get; set; }
    }
    
</code></pre>
<p>Create mapper can be:</p>
<pre><code class="language-c#">CreateMap&lt;Employee, EmployeeDto&gt;()
                .ForMember(dest =&gt; dest.Name,
                opt =&gt; opt.MapFrom(src =&gt; $&quot;{src.FirstName} {src.LastName}&quot;));
</code></pre>
<h5 id="3-combine-two-entities-together">3. Combine two entities together</h5>
<p>When People want to combine Employee and Company to EmployeeDto, it can be:</p>
<pre><code class="language-c#">[HttpGet]
[Route(&quot;&quot;)]
public async Task&lt;ActionResult&lt;IEnumerable&lt;EmpDto&gt;&gt;&gt; GetCompanies()
{
   var companies = await companyRepository.GetCompaniesAsync();
   var emps = await companyRepository.GetEmpAsync();
   var empDtos = mapper.Map&lt; IEnumerable&lt;Company&gt;,
                 IEnumerable&lt;CompDto&gt;&gt;(companies);
   mapper.Map&lt;IEnumerable&lt;Employee&gt;,IEnumerable &lt;CompDto&gt;&gt;(emps, empDtos);
   return Ok(empDtos);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Integration with Google Docs to export documents in ASP.NET core ]]></title>
        <id>https://Helena-Li.github.io/post/integration-with-google-docs-to-export-documents-in-aspnet-core</id>
        <link href="https://Helena-Li.github.io/post/integration-with-google-docs-to-export-documents-in-aspnet-core">
        </link>
        <updated>2020-01-03T03:06:23.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>APIs provided by Google Docs include creating new document, getting a document and  updating a document. However, the function is limited. For example, people can't copy paragraphs; insert text or update styles need the index of the text in Google docs.</p>
<p>Because there are not many example codes for ASP.NET core with C#, I write this article.</p>
<p>To integrate with Google Docs, there are steps:</p>
<ol>
<li>turn on the Google Docs API.</li>
<li>Prepare the project</li>
<li>Manipulate docs in Google Docs</li>
</ol>
<h2 id="turn-on-the-google-docs-api-google-drive-api">Turn on the Google Docs API &amp; Google Drive API</h2>
<p>Creating credential can either refer the official website of Google Docs https://developers.google.com/docs/api/quickstart/dotnet or this article https://thecodehubs.com/google-drive-integration-in-asp-net-mvc/.</p>
<p>Generally, the processing of create credential of Google Docs and Google drive are almost the same. Since I need to copy documents, I need to enable the both APIs. Under the same project in &quot;console.developers.google.com&quot; in &quot;Library&quot; tag, search for them and click enable button.</p>
<h2 id="prepare-the-project">Prepare the project</h2>
<p>Open the NuGet Package Manager Console, install NuGet package of the both API.</p>
<pre><code>Install-Package Google.Apis.Docs.v1
Install-Package Google.Apis.Drive.v3
Install-Package Google.Apis.Drive.v2
</code></pre>
<h2 id="manipulate-docs-in-google-docs">Manipulate docs in Google docs</h2>
<p>I create a tool class for the functions of manipulate docs, and simply use them in the controller without any set up in Program.cs or Startup.cs. The authentication is done also in the tool class.</p>
<h3 id="create-credential-service">Create credential &amp; service</h3>
<pre><code class="language-c#">using Google.Apis.Auth.OAuth2;
using Google.Apis.Docs.v1;
using Google.Apis.Docs.v1.Data;
using Google.Apis.Services;
using Google.Apis.Util.Store;
using System.Threading;
using Microsoft.AspNetCore.Hosting;
using Google.Apis.Drive.v3;
namespace Talent.Api.Domain.Services
{
    public class ProfileService : IProfileService
    {
        static string[] Scopes = { DocsService.Scope.Documents,DocsService.Scope.Drive };
        static string ApplicationName = &quot;Google Docs API Export&quot;;
        static string TemplateDocId = &quot;1WwKfzg0dSjEnZRaOIchD2TT8RqIORsCBfnGpCil1R0c&quot;;
        public async Task&lt;bool&gt; ExportProfileToGoogleDocs(TalentProfileViewModel model)
        {
            try
            {
                UserCredential credential;

                using (var stream = new FileStream(hostingEnvironment.ContentRootPath + 
                &quot;//credentials.json&quot;, FileMode.Open, FileAccess.Read))
                {
                    string credPath = 
                        Environment.GetFolderPath(Environment.SpecialFolder.Personal);
                    credPath = Path.Combine(credPath,
                            $&quot;./credentials/{model.Id}/credentials.json&quot;);

                    credential = GoogleWebAuthorizationBroker.AuthorizeAsync(
                        GoogleClientSecrets.Load(stream).Secrets,
                        Scopes,
                        &quot;user&quot;,
                        CancellationToken.None,
                        new FileDataStore(credPath, true)).Result;
                }
                
                // Create Google Docs API service.
                var service = new DocsService(new BaseClientService.Initializer()
                {
                    HttpClientInitializer = credential,
                    ApplicationName = ApplicationName,
                });

                var serviceDrive = new DriveService(new BaseClientService.Initializer()
                {
                    HttpClientInitializer = credential,
                    ApplicationName = ApplicationName,
                });
            }
        }
    }
}
</code></pre>
<h3 id="copy-template">Copy template</h3>
<p>Use template to generate a document, since replace the text in template with wanted text can maintain the style of the content. So I don't need to specify every style of a letter.</p>
<pre><code class="language-c#">// copy template 
var copyDoc = serviceDrive.Files.Copy(new Google.Apis.Drive.v3.Data.File() { Name = 
      $&quot;Export Profile for {model.FirstName}&quot; },TemplateDocId).Execute();
var docCopyId = copyDoc.Id;
var doc = service.Documents.Get(docCopyId).Execute();
</code></pre>
<p>If you look at the network of the request of &quot;get()&quot;, you can see the structure of the document in Google Doc.</p>
<h3 id="export-text-into-the-document">Export text into the document</h3>
<p>I get some data from the front-end to export to the document. Here I use the tool class to generate the request list.</p>
<pre><code class="language-c#"> // export data to google doc
ExportDataToGoogleDocs export = new ExportDataToGoogleDocs();
List&lt;Request&gt; requests = export.GetRequest(model, doc.Body.Content);

BatchUpdateDocumentRequest body = new BatchUpdateDocumentRequest() { Requests = requests };
BatchUpdateDocumentResponse response = service.Documents
                        .BatchUpdate(body, doc.DocumentId).Execute();
</code></pre>
<h3 id="codes-in-the-tool-class">Codes in the tool class</h3>
<p>There are codes of insert text, replace text, update text style, create and clear bullet, etc.</p>
<pre><code class="language-c#">public class ExportDataToGoogleDocs
    {
        public List&lt;Request&gt; GetRequest(DataViewModel model, 
                                        IList&lt;StructuralElement&gt; DocContent)
        {
            try
            {
                List&lt;Request&gt; requests = new List&lt;Request&gt;();
                string text = null;
                if (model?.Certifications.Count &gt; 0)
                {
                    int index = GetIndex(&quot;{{certification}}&quot;, DocContent);
                    if (index &gt; 0)
                    {
                        int length = 0;
                        for (int i = model.Certifications.Count; i &gt; 0; i--)
                        {
                            var cert = model.Certifications[i - 1];
                            requests.Add(InsertTextRequest(cert.Name + &quot;, &quot;
                                + cert.From + &quot;, &quot; + cert.Year + &quot;\n&quot;, index));
                            length = (cert.Name + &quot;, &quot; + cert.From
                                + &quot;, &quot; + cert.Year).Length;
                            requests.Add(UpdateTextStyleRequest(index, length));
                            length = cert.Name.Length;
                            requests.Add(UpdateTextStyleRequest(index, length, 11.0, 
                                                                true));
                        }
                    }
                }
                else
                {
                    text = &quot;Your certification\n&quot;;
                }
                requests.Add(NewReplaceRequest(&quot;{{certification}}&quot;, text));

                text = null;
                if (model.Education.Count &gt; 0)
                {
                    int index = GetIndex(&quot;{{education}}&quot;, DocContent);
                    if (index &gt; 0)
                    {
                        int length = 0;
                        for (int i = model.Education.Count; i &gt; 0; i--)
                        {
                            var education = model.Education[i - 1];
                            requests.Add(InsertTextRequest(education.Degree + &quot;, &quot;
                                + education.YearOfGraduation + &quot;, &quot; + 
                                education.InstituteName
                                + &quot;, &quot; + education.Country + &quot;\n&quot;, index));
                            length = (education.Degree + &quot;, &quot; + 
                                education.YearOfGraduation + &quot;, &quot;
                                + education.InstituteName + &quot;, &quot; + 
                                education.Country).Length;
                            requests.Add(UpdateTextStyleRequest(index, length));
                            length = education.Degree.Length;
                            requests.Add(UpdateTextStyleRequest(index, length, 11.0, 
                                                                true));
                        }
                    }
                }
                else { text = &quot;Your education\n&quot;; }
                requests.Add(NewReplaceRequest(&quot;{{education}}&quot;, text));

                text = null;
                if (model.Experience.Count &gt; 0)
                {
                    int index = GetIndex(&quot;{{experience}}&quot;, DocContent);
                    if (index &gt; 0)
                    {
                        for (var i = model.Experience.Count; i &gt; 0; i--)
                        {
                            var experience = model.Experience[i - 1];
                            foreach (var desc in 
                                     experience.Responsibilities.Split(&quot;\n&quot;).Reverse())
                            {
                                if (desc.Length == 0) continue;
                                requests.Add(InsertTextRequest(desc + &quot;\n&quot;, index));
                                requests.Add(UpdateTextStyleRequest(index, desc.Length));
                                requests.Add(AddBulletStyleRequest(index, desc.Length));
                            }
                            requests.Add(InsertTextRequest(experience.Position + &quot;\n&quot;, 
                                                           index));
                            requests.Add(ClearBulletStyleRequest(index));
                            requests.Add(UpdateTextStyleRequest(index,
                                experience.Position.Length, 11.0, true));
                            var info = experience.Company + &quot;, &quot; + 
                                experience.Start.ToShortDateString()
                                + &quot; - &quot; + experience.End.ToShortDateString() + &quot;\n&quot;;
                            requests.Add(InsertTextRequest(info, index));
                            requests.Add(UpdateTextStyleRequest(index, info.Length));
                            requests.Add(UpdateTextStyleRequest(index, 
                               experience.Company.Length, 11.0, true));
                        }
                    }
                }
                else { text = &quot;Your experience\n&quot;; }
                requests.Add(NewReplaceRequest(&quot;{{experience}}&quot;, text));

                text = null;
                int skillIndex = GetIndex(&quot;{{skills}}&quot;, DocContent);
                if (skillIndex &gt; 0)
                {
                    if (model.Skills.Count &gt; 0)
                    {
                        foreach (var skill in model.Skills.AsEnumerable().Reverse())
                        {
                            requests.Add(InsertTextRequest(skill.Name + &quot;\n&quot;, 
                                                           skillIndex));
                            requests.Add(AddBulletStyleRequest(skillIndex,
                                                               skill.Name.Length));
                        }
                    }
                    else { text = &quot;Your skills\n&quot;; }
                    requests.Add(NewReplaceRequest(&quot;{{skills}}&quot;, text));
                }

                text = (model.FirstName.Length &gt; 0 &amp;&amp; model.LastName.Length &gt; 0) ?
                     model.FirstName + &quot; &quot; + model.MiddleName + &quot; &quot; + model.LastName
                    : &quot;Your Name&quot;;
                requests.Add(NewReplaceRequest(&quot;{{name}}&quot;, text));

                text = model.Address.City.Length &gt; 0 &amp;&amp; model.Address.Country.Length &gt; 0
                    &amp;&amp; model.Address.Street.Length &gt; 0 ?
                    model.Address.Number + &quot; &quot; + model.Address.Street + &quot;, &quot; + 
                    model.Address.Suburb + &quot;, &quot;
                    + model.Address.City + &quot;, &quot; + model.Address.Country :
                    &quot;Your address&quot;;
                requests.Add(NewReplaceRequest(&quot;{{address}}&quot;, text));

                text = model.Phone ?? &quot;021 *** ***&quot;;
                requests.Add(NewReplaceRequest(&quot;{{phone}}&quot;, text));

                text = model.Email ?? &quot;name@example.com&quot;;
                requests.Add(NewReplaceRequest(&quot;{{email}}&quot;, text));

                text = model.Summary ?? &quot;Something about you&quot;;
                requests.Add(NewReplaceRequest(&quot;{{summary}}&quot;, text));

                return requests;
            }
            catch (Exception)
            {
                return null;
            }
        }

        private static Request NewReplaceRequest(string preContent, 
                                                 string replaceContent)
        {
            Request request = new Request();
            request.ReplaceAllText = new ReplaceAllTextRequest()
            {
                ContainsText = new SubstringMatchCriteria()
                {
                    Text = (preContent),
                    MatchCase = true
                },
                ReplaceText = replaceContent
            };
            return request;
        }

        private static Request InsertTextRequest(string content, int index)
        {
            Request request = new Request();
            request.InsertText = new InsertTextRequest()
            {
                Text = content,
                Location = new Location() { Index = index }
            };
            return request;
        }

        private static Request AddBulletStyleRequest(int startIndex, int length)
        {
            Request request = new Request();
            request.CreateParagraphBullets = new CreateParagraphBulletsRequest
            {
                Range = new Range { StartIndex = startIndex, EndIndex = startIndex + 
                    length },
                BulletPreset = &quot;BULLET_DISC_CIRCLE_SQUARE&quot;
            };
            return request;
        }

        private static Request ClearBulletStyleRequest(int startIndex)
        {
            Request request = new Request();
            request.DeleteParagraphBullets = new DeleteParagraphBulletsRequest
            {
                Range = new Range { StartIndex = startIndex, EndIndex = startIndex + 1 }
            };
            return request;
        }

        private static Request UpdateTextStyleRequest(int startIndex, int length,
              double fontSize = 11, bool bold = false)
        {
            Request request = new Request();
            request.UpdateTextStyle = new UpdateTextStyleRequest()
            {
                TextStyle = new TextStyle()
                {
                    FontSize = new Dimension() { Magnitude = fontSize, Unit = &quot;PT&quot; },
                    Bold = bold
                },
                Range = new Range() { StartIndex = startIndex, EndIndex = startIndex + 
                    length },
                Fields = &quot;fontSize, bold&quot;
            };
            return request;
        }

        private static int GetIndex(string stringToFind, 
                                    IList&lt;StructuralElement&gt; DocContent)
        {
            var result = DocContent.Where(a =&gt; a.Paragraph != null)
                .FirstOrDefault(x =&gt; x.Paragraph.Elements.Any(
                    y =&gt; y.TextRun.Content.StartsWith(stringToFind, 
                                                      StringComparison.CurrentCulture)
                    ));
            if (result == null)
            {
                return 0;
            }
            return (int)result.StartIndex;
        }

    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sign in with Google+ API - GetExternalLoginInfoAsync return null]]></title>
        <id>https://Helena-Li.github.io/post/sign-in-with-google-api-getexternallogininfoasync-return-null</id>
        <link href="https://Helena-Li.github.io/post/sign-in-with-google-api-getexternallogininfoasync-return-null">
        </link>
        <updated>2019-12-23T10:00:30.000Z</updated>
        <content type="html"><![CDATA[<p>When I try to sign in with Google authentication, I encounter an issue that I can't receive information by using signInManager.GetExternalLoginInfoAsync(). This is because Google plus is shutting down. Here I give the overall codes and sources for google authentication. I used ASP.NET core 2.2.</p>
<p>The process of create a Google API console project is :</p>
<ol>
<li>Create Google oauth credentials client Id and secret.</li>
<li>Set up API and configure</li>
</ol>
<h2 id="1-create-google-oauth-credentials-client-id-and-secret">1. Create Google oauth credentials client Id and secret.</h2>
<p>Learn to create client Id and secret by this link: https://docs.microsoft.com/en-US/aspnet/core/security/authentication/social/google-logins?view=aspnetcore-3.1</p>
<p>Notice: enable SSL, e.g., use https://localhost:44306/signin-google for Authorised redirect URIs in oauth client IDs in Credentials.</p>
<h2 id="2-set-up-api-and-configure">2. Set up API and configure</h2>
<p>In startup.cs, add configure service :</p>
<pre><code class="language-c#">services.AddAuthentication().AddGoogle(option =&gt;
            {
                option.ClientId = &quot;597035172561-c50s2qu28fj78tl1lmivb6v8tpsr9qta.apps.googleusercontent.com&quot;;
                option.ClientSecret = &quot;vGIslMG3NOGqcLKdc8uwmu-n&quot;;
                //option.UserInformationEndpoint = &quot;https://www.googleapis.com/oauth2/v1/certs&quot;;
                option.UserInformationEndpoint = &quot;https://www.googleapis.com/oauth2/v2/userinfo&quot;;
                option.ClaimActions.Clear();
                option.ClaimActions.MapJsonKey(ClaimTypes.NameIdentifier, &quot;id&quot;);
                option.ClaimActions.MapJsonKey(ClaimTypes.Name, &quot;name&quot;);
                option.ClaimActions.MapJsonKey(ClaimTypes.GivenName, &quot;given_name&quot;);
                option.ClaimActions.MapJsonKey(ClaimTypes.Surname, &quot;family_name&quot;);
                option.ClaimActions.MapJsonKey(&quot;urn:google:profile&quot;, &quot;link&quot;);
                option.ClaimActions.MapJsonKey(ClaimTypes.Email, &quot;email&quot;);
            });
</code></pre>
<p>Notice: just input clientID and ClientSecret will through an exception &quot;HttpRequestException: An error occurred when retrieving Google user information (Forbidden). Please check if the authentication information is correct and the corresponding Google+ API is enabled.&quot; This is because Google plus is shutting down. I tried to add an UserInformationEndpoint but found that I can't receive information by using signInManager.GetExternalLoginInfoAsync().  Codes in the controller are:</p>
<pre><code class="language-c#"> [HttpPost]
 [AllowAnonymous]
 public IActionResult ExternalLogin(string provider, string returnUrl)
{
    var redirectUrl = Url.Action(&quot;ExternalLoginCallback&quot;, &quot;account&quot;,
                new { ReturnUrl = returnUrl });
    var properties = signInManager
        .ConfigureExternalAuthenticationProperties(provider,redirectUrl);
    return new ChallengeResult(provider, properties);
}
</code></pre>
<pre><code class="language-c#"> [AllowAnonymous]
public async Task&lt;IActionResult&gt; ExternalLoginCallback
            (string returnUrl = null,string remoteError = null)
{
     returnUrl = returnUrl ?? Url.Content(&quot;~/&quot;);
     var info = await signInManager.GetExternalLoginInfoAsync();
    // info should contain user information after successful signed in google.
     var signInResult = await signInManager.
         ExternalLoginSignInAsync(info.LoginProvider,
                info.ProviderKey, isPersistent: false, bypassTwoFactor: true);
}
</code></pre>
<h2 id="official-announcement">Official announcement</h2>
<p>https://github.com/aspnet/AspNetCore/issues/6486</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tag helpers not creating proper URL]]></title>
        <id>https://Helena-Li.github.io/post/tag-helpers-not-creating-proper-url</id>
        <link href="https://Helena-Li.github.io/post/tag-helpers-not-creating-proper-url">
        </link>
        <updated>2019-12-06T21:05:05.000Z</updated>
        <content type="html"><![CDATA[<p>Tag Helpers enable server-side code to participate in creating and rendering HTML elements in Razor files. There are many built-in Tag Helpers for common tasks - such as creating forms, links, image version number.<br>
We are going to solve the issue that URL is not generated properly. There are several things to check:</p>
<h3 id="import-tag-helper-correctly">Import tag helper correctly</h3>
<p>In the _ViewImports.cshtml file, import tag helper as follow.</p>
<pre><code>@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers
</code></pre>
<p>Notice:  _ViewImports.cshtml should under the &quot;Views&quot; folder, since it works only for files in the &quot;Views&quot; directory or sub-directory.</p>
<h3 id="include-tag-helper-in-dependencies">Include tag helper in dependencies</h3>
<p>Make sure &quot;Microsoft.AspNetCore.Mvc.TagHelpers&quot; is referred in the dependencies folder in Nuget.</p>
<h3 id="check-self-defined-routes-in-startupcs">Check self-defined routes in Startup.cs</h3>
<p>Check the routes whether the codes in .cshtml files is consist with the template route.</p>
<p>For example in my case, my route is :</p>
<pre><code class="language-c#">Startup.cs:

app.UseMvc(routes =&gt;
            {
                routes.MapRoute(&quot;default&quot;, &quot;{controller=home}/{action=index}/{id?}&quot;);
            });
</code></pre>
<p>When using tag helper for generate link, codes are like this in _​Layout.cshtml :</p>
<pre><code class="language-html">&lt;ul class=&quot;navbar-nav&quot;&gt;
    &lt;li class=&quot;nav-item&quot;&gt;
       &lt;a asp-action=&quot;index&quot; asp-controller=&quot;home&quot; class=&quot;nav-link&quot;&gt;List&lt;/a&gt;
    &lt;/li&gt;
    &lt;li class=&quot;nav-item&quot;&gt;
       &lt;a asp-action=&quot;create&quot; asp-controller=&quot;home&quot; class=&quot;nav-link&quot;&gt;Create&lt;/a&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Then the links are generated :</p>
<pre><code class="language-html"> &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;collapseNabar&quot;&gt;
      &lt;ul class=&quot;navbar-nav&quot;&gt;
            &lt;li class=&quot;nav-item&quot;&gt;
                &lt;a class=&quot;nav-link&quot; href=&quot;/&quot;&gt;List&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&quot;nav-item&quot;&gt;
                &lt;a class=&quot;nav-link&quot; href=&quot;/home/create&quot;&gt;Create&lt;/a&gt;
            &lt;/li&gt;
      &lt;/ul&gt;
&lt;/div&gt;
</code></pre>
<p>Notice: If you only use app.UseMvc() in the Startup.cs, without a route defination. There might have issues, such as links are not generated. This is because you didn't give a template for routes, tag helper only return a &quot;&quot; as the value of href.</p>
<h3 id="check-attribute-routing">Check Attribute routing</h3>
<p>Strange results occur when you define both self-defined routes in Startup.cs and attribute routing in controller.  Try to use self-defined routes in Startup.cs only when using tag helper, or use app.UseMvc() + attribute routing in controller.</p>
<pre><code class="language-c#">HomeController:

[Route(&quot;&quot;)]   // delete these attribute routing when use self-defined routes
[Route(&quot;Home&quot;)]
[Route(&quot;Home/Index&quot;)] 
public ViewResult Index()
{
    var model = _employeeRepository.GetAllEmployee();
    return View(model);
}
</code></pre>
<pre><code class="language-c#">public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseStaticFiles();
            app.UseMvc();
        }
</code></pre>
]]></content>
    </entry>
</feed>